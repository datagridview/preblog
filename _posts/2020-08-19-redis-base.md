---
layout: page
title: redis原理解析 
---
- [SDS结构](#sds结构)
- [为什么用sds而不是c字符串？](#为什么用sds而不是c字符串)
- [哈希表结构](#哈希表结构)
- [哈希表节点（dictEntry）](#哈希表节点dictentry)
- [字典数据结构](#字典数据结构)
- [hash的过程](#hash的过程)
- [rehash的过程](#rehash的过程)
- [跳跃表](#跳跃表)
- [整数集合](#整数集合)
- [压缩列表](#压缩列表)
- [redis对象](#redis对象)
  - [为什么有序集合需要同时使用跳跃表和字典来实现？](#为什么有序集合需要同时使用跳跃表和字典来实现)
- [类型检查](#类型检查)
- [引用计数](#引用计数)
  - [为什么 Redis 不共享包含字符串的对象？](#为什么-redis-不共享包含字符串的对象)
- [LRU值](#lru值)
- [有关数据库](#有关数据库)
- [rdb](#rdb)
- [aof](#aof)
- [事件](#事件)
- [复制](#复制)
- [集群](#集群)
- [pub/sub](#pubsub)
- [事务](#事务)
Redis键值对都是SDS对象（简单动态字符串）

### SDS结构
```c
struct sdshdr {
    // 保存的字符串长度，不包含"\0"，方便重用c语言接口
    int len;
    // 未使用字节的长度
    int free;
    // 字节数组
    int buf[];
};
```

### 为什么用sds而不是c字符串？
1. 获取长度O(1)
2. 防止缓冲区溢出（接口可以检测有没有溢出）
3. n次修改字符串最多需要分配N次
4. 能保存二进制数据

### 哈希表结构
```c
typedef struct dictht {
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表掩码
    unsigned long sizemask;
    //已有节点数量
    unsigned long used;
} dictht;
```

### 哈希表节点（dictEntry）
```c
typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_tu64;
        int64_ts64;
    } v;
    struct dictEntry *next;
} dictEntry;
```

![9dvMNYOEr4T8m2U](https://i.loli.net/2020/08/19/9dvMNYOEr4T8m2U.png)

### 字典数据结构
ht1是用来存储rehash表的
![7HY6GIAjJ1v3Dme](https://i.loli.net/2020/08/19/7HY6GIAjJ1v3Dme.png)

### hash的过程
```
hash = murmurhash(k)
index = hash & sizemask
```

### rehash的过程
1. 给ht[1]分配空间
2. 根据mask重新计算索引值
3. 链表迁移
4. ht[0] = ht[1], free ht[1]

rehash过程是渐进的，在这个过程中，查找是的范围是 ht0 ht1，但是新插入的是ht1

### 跳跃表
[跳跃表原理](https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html)

### 整数集合
如果一个集合内部都是整数，那么就以整数集合的类型保存。
升级：一个新元素比整数集合所有的元素类型都要长，进行升级
降级：不会进行降级

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 数组
    int8_t contents[];
}
```
### 压缩列表

为了节约内存开发的

### redis对象
```c
typedef struct redisObject {
    //类型
    unsigned type:4;

    //编码
    unsigned encoding:4;

    //指向底层实现数据结构的指针
    void *ptr;
    ...
} robj;
```

键为字符串对象，值可以为任意对象。

type：
![C4ZWjniQbHSKeN1](https://i.loli.net/2020/08/19/C4ZWjniQbHSKeN1.png)

encoding：
![uc39RPq12bEdAsL](https://i.loli.net/2020/08/19/uc39RPq12bEdAsL.png)

通过`object encoding`可以输出不同对象的编码类型

**字符串对象**：int整数、raw（SDS）、embstr（小于32个字节的字符串对象，只读，改变时会转换为raw）

![zQSvon8Ckq3TBRm](https://i.loli.net/2020/08/19/zQSvon8Ckq3TBRm.png)

**列表对象**：ziplist（压缩列表，内所有元素都小于64，个数小于512，转化后是单向的）、linkedlist（双端链表）、3.2以后使用只quicklist

**哈希对象**：ziplist（key、value空间上挨着，转化同上）、hashtable

**集合对象**：intset（都是整数、不超过512个）、hashtable（键是集合对象，值为null）

**有序集合**：ziplist（大于128个或某个大于64字节，进行转换） 或者 skiplist 。
```c
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```

![FPHj6Dc7esl25yo](https://i.loli.net/2020/08/19/FPHj6Dc7esl25yo.png)

#### 为什么有序集合需要同时使用跳跃表和字典来实现？

在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。

举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。

另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。

因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。


### 类型检查
DEL 、 EXPIRE 等命令和 LLEN 等命令的区别在于， 前者是基于类型的多态 —— 一个命令可以同时用于处理多种不同类型的键， 而后者是基于编码的多态 —— 一个命令可以同时用于处理多种不同编码。

### 引用计数
对象的引用计数信息会随着对象的使用状态而不断变化：

* 在创建一个新对象时， 引用计数的值会被初始化为 1 ；
* 当对象被一个新程序使用时， 它的引用计数值会被增一；
* 当对象不再被一个程序使用时， 它的引用计数值会被减一；
* 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。

目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。

 OBJECT REFCOUNT查看引用数

#### 为什么 Redis 不共享包含字符串的对象？

当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：

如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；
如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；
如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。
因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。

### LRU值
OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的；
OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 lru 属性。

### 有关数据库
* Redis 服务器的所有数据库都保存在 redisServer.db 数组中， 而数据库的数量则由 redisServer.dbnum 属性保存。
* 客户端通过修改目标数据库指针， 让它指向 redisServer.db 数组中的不同元素来切换不同的数据库。
* 数据库主要由 dict 和 expires 两个字典构成， 其中 dict 字典负责保存键值对， 而 expires 字典则负责保存键的过期时间。
* 因为数据库由字典构成， 所以对数据库的操作都是建立在字典操作之上的。
* 数据库的键总是一个字符串对象， 而值则可以是任意一种 Redis 对象类型， 包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象， 分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
* expires 字典的键指向数据库中的某个键， 而值则记录了数据库键的过期时间， 过期时间是一个以毫秒为单位的 UNIX 时间戳。
* Redis 使用惰性删除和定期删除两种策略来删除过期的键： 惰性删除策略只在碰到过期键时才进行删除操作， 定期删除策略则每隔一段时间， 主动查找并删除过期键。
* 执行 SAVE 命令或者 BGSAVE 命令所产生的新 RDB 文件不会包含已经过期的键。
* 执行 BGREWRITEAOF 命令所产生的重写 AOF 文件不会包含已经过期的键。
* 当一个过期键被删除之后， 服务器会追加一条 DEL 命令到现有 AOF 文件的末尾， 显式地删除过期键。
* 当主服务器删除一个过期键之后， 它会向所有从服务器发送一条 DEL 命令， 显式地删除过期键。
* 从服务器即使发现过期键， 也不会自作主张地删除它， 而是等待主节点发来 DEL 命令， 这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。
* 当 Redis 命令对数据库进行修改之后， 服务器会根据配置， 向客户端发送数据库通知。

### rdb
* RDB 文件用于保存和还原 Redis 服务器所有数据库中的所有键值对数据。
* SAVE 命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
* BGSAVE 命令由子进程执行保存操作，所以该命令不会阻塞服务器。
* 服务器状态中会保存所有用 save 选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行 BGSAVE 命令。
* RDB 文件是一个经过压缩的二进制文件，由多个部分组成。
* 对于不同类型的键值对， RDB 文件会使用不同的方式来保存它们。

### aof
* AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
* AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存。
* 命令请求会先保存到 AOF 缓冲区里面， 之后再定期写入并同步到 AOF 文件。
* appendfsync 选项的不同值对 AOF 持久化功能的安全性、以及 Redis 服务器的性能有很大的影响。
* 服务器只要载入并重新执行保存在 AOF 文件中的命令， 就可以还原数据库本来的状态。
* AOF 重写可以产生一个新的 AOF 文件， 这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样， 但体积更小。
* AOF 重写是一个有歧义的名字， 该功能是通过读取数据库中的键值对来实现的， 程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。
* 在执行 BGREWRITEAOF 命令时， Redis 服务器会维护一个 AOF 重写缓冲区， 该缓冲区会在子进程创建新 AOF 文件的期间， 记录服务器执行的所有写命令。 当子进程完成创建新 AOF 文件的工作之后， 服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾， 使得新旧两个 AOF 文件所保存的数据库状态一致。 最后， 服务器用新的 AOF 文件替换旧的 AOF 文件， 以此来完成 AOF 文件重写操作。

### 事件

* Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。
* 文件事件处理器是基于 Reactor 模式实现的网络通讯程序。
* 文件事件是对套接字操作的抽象： 每次套接字变得可应答（acceptable）、可写（writable）或者可读（readable）时， 相应的文件事件就会产生。
* 文件事件分为 AE_READABLE 事件（读事件）和 AE_WRITABLE 事件（写事件）两类。
* 时间事件分为定时事件和周期性事件： 定时事件只在指定的时间达到一次， 而周期性事件则每隔一段时间到达一次。
* 服务器在一般情况下只执行 serverCron 函数一个时间事件， 并且这个事件是周期性事件。
* 文件事件和时间事件之间是合作关系， 服务器会轮流处理这两种事件， 并且处理事件的过程中也不会进行抢占。
* 时间事件的实际处理时间通常会比设定的到达时间晚一些。

一个命令请求从发送到完成主要包括以下步骤： 1. 客户端将命令请求发送给服务器； 2. 服务器读取命令请求，并分析出命令参数； 3. 命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复； 4. 服务器将命令回复返回给客户端。


### 复制
* Sentinel 只是一个运行在特殊模式下的 Redis 服务器， 它使用了和普通模式不同的命令表， 所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。
* Sentinel 会读入用户指定的配置文件， 为每个要被监视的主服务器创建相应的实例结构， 并创建连向主服务器的命令连接和订阅连接， 其中命令连接用于向主服务器发送命令请求， 而订阅连接则用于接收指定频道的消息。
* Sentinel 通过向主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息， 并为这些从服务器创建相应的实例结构， 以及连向这些从服务器的命令连接和订阅连接。
* 在一般情况下， Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令， 当主服务器处于下线状态， 或者 Sentinel 正在对主服务器进行故障转移操作时， Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。
* 对于监视同一个主服务器和从服务器的多个 Sentinel 来说， 它们会以每两秒一次的频率， 通过向被监视服务器的 __sentinel__:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。
* 每个 Sentinel 也会从 __sentinel__:hello 频道中接收其他 Sentinel 发来的信息， 并根据这些信息为其他 Sentinel 创建相应的实例结构， 以及命令连接。
* Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接， Sentinel 与 Sentinel 之间则只创建命令连接。
* Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令， 并根据实例对 PING 命令的回复来判断实例是否在线： 当一个实例在指定的时长中连续向 Sentinel 发送无效回复时， Sentinel 会将这个实例判断为主观下线。
* 当 Sentinel 将一个主服务器判断为主观下线时， 它会向同样监视这个主服务器的其他 Sentinel 进行询问， 看它们是否同意这个主服务器已经进入主观下线状态。
* 当 Sentinel 收集到足够多的主观下线投票之后， 它会将主服务器判断为客观下线， 并发起一次针对主服务器的故障转移操作。

### 集群
* 节点通过握手来将其他节点添加到自己所处的集群当中。
* 集群中的 16384 个槽可以分别指派给集群中的各个节点， 每个节点都会记录哪些槽指派给了自己， 而哪些槽又被指派给了其他节点。
* 节点在接到一个命令请求时， 会先检查这个命令请求要处理的键所在的槽是否由自己负责， 如果不是的话， 节点将向客户端返回一个 MOVED 错误， MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。
* 对 Redis 集群的重新分片工作是由客户端执行的， 重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。
* 如果节点 A 正在迁移槽 i 至节点 B ， 那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时， 节点 A 会向客户端返回一个 ASK 错误， 指引客户端到节点 B 继续查找指定的数据库键。
* MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点， 而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。
* 集群里的从节点用于复制主节点， 并在主节点下线时， 代替主节点继续处理命令请求。
* 集群中的节点通过发送和接收消息来进行通讯， 常见的消息包括 MEET 、 PING 、 PONG 、 PUBLISH 、 FAIL 五种。

### pub/sub
* 服务器状态在 pubsub_channels 字典保存了所有频道的订阅关系： SUBSCRIBE 命令负责将客户端和被订阅的频道关联到这个字典里面， 而 UNSUBSCRIBE 命令则负责解除客户端和被退订频道之间的关联。
* 服务器状态在 pubsub_patterns 链表保存了所有模式的订阅关系： PSUBSCRIBE 命令负责将客户端和被订阅的模式记录到这个链表中， 而 UNSUBSCRIBE 命令则负责移除客户端和被退订模式在链表中的记录。
* PUBLISH 命令通过访问 pubsub_channels 字典来向频道的所有订阅者发送消息， 通过访问 pubsub_patterns 链表来向所有匹配频道的模式的订阅者发送消息。
* PUBSUB 命令的三个子命令都是通过读取 pubsub_channels 字典和 pubsub_patterns 链表中的信息来实现的。

### 事务
* 事务提供了一种将多个命令打包， 然后一次性、有序地执行的机制。
* 多个命令会被入队到事务队列中， 然后按先进先出（FIFO）的顺序执行。
* 事务在执行过程中不会被中断， 当事务队列中的所有命令都被执行完毕之后， 事务才会结束。
* 带有 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联， 当键被修改时， 程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 标志打开。
* 只有在客户端的 REDIS_DIRTY_CAS 标志未被打开时， 服务器才会执行客户端提交的事务， 否则的话， 服务器将拒绝执行客户端提交的事务。
* Redis 的事务总是保证 ACID 中的原子性、一致性和隔离性， 当服务器运行在 AOF 持久化模式下， 并且 appendfsync 选项的值为 always 时， 事务也具有耐久性。
