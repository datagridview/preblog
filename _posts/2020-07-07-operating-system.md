---
layout: page
title: 操作系统相关
---
- [什么是系统调用？](#什么是系统调用)
- [什么是进程？什么是线程？](#什么是进程什么是线程)
- [进程和线程有什么区别](#进程和线程有什么区别)
- [进程有哪几种状态？](#进程有哪几种状态)
- [什么是竞争条件？](#什么是竞争条件)
- [什么是临界区？](#什么是临界区)
- [进程同步和进程通信有什么区别？](#进程同步和进程通信有什么区别)
- [进程通信是怎么实现的？](#进程通信是怎么实现的)
- [线程通信是怎么实现的？](#线程通信是怎么实现的)
- [僵死进程和孤儿进程的区别？](#僵死进程和孤儿进程的区别)
  - [信号的处理流程是怎么样的？](#信号的处理流程是怎么样的)
  - [Linux中三种信号量？](#linux中三种信号量)
  - [什么是互斥？](#什么是互斥)
  - [什么是同步？](#什么是同步)
- [进程如何获取一个共享资源？](#进程如何获取一个共享资源)
- [进程的调度算法有哪些？](#进程的调度算法有哪些)
- [什么是死锁？为什么会产生死锁？有什么解决方案？](#什么是死锁为什么会产生死锁有什么解决方案)
- [内存管理机制有哪些？](#内存管理机制有哪些)
- [分页和分段有什么区别？](#分页和分段有什么区别)
- [什么是快表？](#什么是快表)
- [什么是虚拟内存？什么是虚拟地址空间？](#什么是虚拟内存什么是虚拟地址空间)
- [虚拟内存有什么好处？](#虚拟内存有什么好处)
- [缺页中断的过程是怎么样的？](#缺页中断的过程是怎么样的)
- [什么是多级页表？](#什么是多级页表)
- [有哪些页面置换算法？](#有哪些页面置换算法)
- [什么是局部性原理？](#什么是局部性原理)
- [Python的线程调度？](#python的线程调度)
- [有哪几种I/O模型？](#有哪几种io模型)
- [什么是多路复用？](#什么是多路复用)
  - [select](#select)
  - [poll](#poll)
  - [epoll](#epoll)
- [linux如何实现共享内存？](#linux如何实现共享内存)
- [如何进行磁盘调度？](#如何进行磁盘调度)
- [wait和waitpid是干嘛的？](#wait和waitpid是干嘛的)
  - [每个进程中的内容](#每个进程中的内容)
  - [每个线程中的内容](#每个线程中的内容)


### 什么是系统调用？
用于用户程序从用户态转换为内核态。（使用陷阱而不是指令实现系统调用）

内核态中，操作系统对于所有的硬件具有完全的访问权，可以运行任何指令。

用户态中，只能使用机器指令中的一个子集，不能运行I/O等操作指令。

如果一个程序正在用户态运行一个用户程序，当他需要一个系统服务的时候，他就需要切换到内核态去执行这个过程调用。这个过程就是系统调用。

### 什么是进程？什么是线程？
进程是对正在运行程序的一种抽象，进程有独立的地址空间。

线程是划分进程的更小单位，同一个进程内的线程共享线程的堆和资源。

### 进程和线程有什么区别
* 线程共享资源，进程独立运行
* 线程独立调度，切换不会引起进程切换；进程切换会引起线程切换
* 进程更加的轻量，更快，开销更小
* 多CPU对于线程有益，真正实现并行
* 进程间通信需要IPC，线程可以通过访问进程的共享资源

### 进程有哪几种状态？
创建、就绪、阻塞、运行、终止

### 什么是竞争条件？
两个或者多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。

### 什么是临界区？
对于共享内存进行访问的程序片段。

如果能够将两个进程不再同时处于临界区时就能避免竞争条件。

### 进程同步和进程通信有什么区别？
进程同步：控制多个进程按一定顺序执行
进程通信：进程间传输信息

### 进程通信是怎么实现的？
* 匿名管道：半双工、只支持亲子关系、本质上是内核缓冲区的FIFO、无格式字节流。当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开
* 有名管道：存在于文件系统中，通过访问文件来通讯，FIFO
* 信号：用于通知接受进程有某种事件发生，进程将一直保有这个信号直到执行
* 消息队列：存在内核的消息链表中，包括Posix消息队列system V消息队列。有权限的进程可读可写可查询，不需要读等待。
* 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式，需要同步机制
* 信号量：同步与互斥
* 套接字：本地/网络通信，更具一般性

### 线程通信是怎么实现的？
线程间的通信目的主要是用于线程同步。
1. 锁机制：互斥锁、条件变量、读写锁和自旋锁。
  **互斥锁**确保同一时间只能有一个线程访问共享资源。
  **读写锁**当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
  **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
  **自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 
2. 信号量：和进程类似
3. 信号：和进程类似

### 僵死进程和孤儿进程的区别？
**孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵死进程**：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。


#### 信号的处理流程是怎么样的？
* 进程产生信号，设置传给的进程pid，传给操作系统内核
* 根据接受者判断，阻塞先保留，运行直接发，退出就丢弃
* 收到信号，终止代码执行，保护上下文，执行中断，然后回到中断

#### Linux中三种信号量？
* POSIX有名信号量
* POSIX基于内存的信号量
* System V信号量

#### 什么是互斥？
某一资源某一时刻只允许有一个进程访问，具有唯一性和排他性，无法限制访问者的访问顺序

#### 什么是同步？
在互斥的基础上实现有序访问

### 进程如何获取一个共享资源？
1. 创建信号量
2. P操作：等待一个信号量，值等于0就阻塞，大于0就减1（用掉一个保存的唤醒信号）
3. V操作：挂出一个信号量，信号量减1

### 进程的调度算法有哪些？
* 先来先服务（FCFS）：就绪队列中最先进入的，执行到完成或者阻塞
* 短作业优先（SJF）：就绪中选择预估最快能完成的
* 时间片轮转（RR）：每个都被分配一定的时间
* 优先级调度：根据内存要求、时间要求、资源分配要求分配优先级
* 多级反馈队列：既能使短作业完成，又能让优先级高的得到响应


### 什么是死锁？为什么会产生死锁？有什么解决方案？
两个或多个进程之间相互阻塞，与不可抢占的资源相关

产生死锁的条件：
* 互斥条件
* 循环等待
* 不可剥夺
* 请求保持

解决方案：
* 鸵鸟策略：不管
* 死锁预防：破坏四个条件中的一个
* 死锁避免：银行家算法
* 死锁检测
* 死锁解除：资源剥夺、撤销进程

### 内存管理机制有哪些？
连续分配 - 块式
离散分配 - **页式**、**段式**（分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。）、**段页式**（每个段上的地址空间划分成大小相同的页）

### 分页和分段有什么区别？
相同：提高内存的利用率；离散存储但内部连续
不同：页大小固定，段大小不固定；分页好管理，分段好理解

分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 什么是快表？
解决了CPU中MMU将虚拟地址到物理地址转换速度的问题，是地址缓冲表。
流程：
1. 根据虚拟地址中的页号查询快表
2. 如果查到就直接读取物理地址
3. 如果没有就访问内存中的页表，得到物理地址，并将表映射关系加到快表当中
4. 表满时，使用淘汰策略淘汰其中的一页

### 什么是虚拟内存？什么是虚拟地址空间？
为了让硬件能够运行需要大内存的程序，将程序分成多个页面，动态的换入换出。

虚拟内存时对于主存的抽象，且只有在离散内存分配基础上才能够实现虚拟内存。

用页面的调入调出时间换取更大的空间。

### 虚拟内存有什么好处？
* 扩展可用空间
* 每个进程拥有逻辑上连续的内存空间
* 保护进程的独立资源

### 缺页中断的过程是怎么样的？
1. MMU查询页表时发现相应虚拟地址没有被映射
2. 在主存上没有相关页
3. 调页调段
4. 继续执行


### 什么是多级页表？
解决大内存页表问题。

时间换空间，避免所有页表放在内存中

### 有哪些页面置换算法？
页面置换算法是在内存空间不够用的情况下，选择淘汰的页面的策略。
* OPT：最佳页面置换算法：不可能实现
* FIFO：先进先出
* NRU：最近未使用：随机从类编号最小的非空类中挑选一个页面淘汰
* clock：时钟，直到找到第一个R位为0的页面，将他淘汰
* LRU：最近最少使用：维护一个链表代价很高，或者在页表中加一项（需要硬件支持）
* NFU：最少使用：每次时钟中断就扫描所有内存页面，加R的和算频数（LRU的粗略估计）
* 老化算法：维护一个计数器，记录之前活跃的一张表。缺页中断时置换值最小的表。
![tEwR6rVL437TQBl](https://i.loli.net/2020/07/08/tEwR6rVL437TQBl.png)

### 什么是局部性原理？
表现在时间局部性和空间局部性两个方面。

时间局部性：指令可能被再次执行，数据可能被再次访问（循环操作）

空间局部性：同一段时间内访问的地址可能在空间上聚集

### Python的线程调度？

### 有哪几种I/O模型？
* 阻塞I/O：使用系统调用，并一直阻塞直到内核将数据准备好，之后再由内核缓冲区复制到用户态，在等待内核准备的这段时间什么也干不了。除非特别指明，几乎所有I/O都是阻塞的。
* 非阻塞I/O：非阻塞式IO的轮询会耗费大量cpu，通常在专门提供某一功能的系统中才会使用。需要用户进程不断询问内核数据有没有准备好。
* I/O多路复用：select/poll/epoll，类似于非阻塞，只不过轮询不是由用户线程去执行，而是由内核去轮询，内核监听程序监听到数据准备好后，调用内核函数复制数据到用户态
* 信号驱动I/O
* 异步I/O：发起操作立即返回，由内核发送信号给用户进程通知完成。

**模型比较**
* 同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。
* 异步 I/O：第二阶段应用进程不会阻塞。

同步 I/O 包括阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O ，它们的主要区别在第一个阶段。

非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。



![gysNbfd2ZzjwlCR](https://i.loli.net/2020/07/08/gysNbfd2ZzjwlCR.png)

### 什么是多路复用？
* select：线性扫描所有监听的文件描述符，不管他们是不是活跃的。有最大数量限制（32位系统1024，64位系统2048）
* poll：同select，不过数据结构不同，需要分配一个pollfd结构数组，维护在内核中。它没有大小限制，不过需要很多复制操作
* epoll：用于代替poll和select，没有大小限制。使用一个文件描述符管理多个文件描述符，使用红黑树存储。同时用事件驱动代替了轮询。epoll_ctl中注册的文件描述符在事件触发的时候会通过回调机制激活该文件描述符。epoll_wait便会收到通知。最后，epoll还采用了mmap虚拟内存映射技术减少用户态和内核态数据传输的开销

* select 应用场景：select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。

*  poll 应用场景：poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。

* epoll 应用场景：只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。

#### select
select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。

fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。

timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。

成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。

#### poll
poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。

poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：
```c
struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };
```

#### epoll
epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。

从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。

epoll 仅适用于 Linux OS。

epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。

epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。

epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。

1. LT 模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

2. ET 模式：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。


### linux如何实现共享内存？
共享内存是通过把同一块内存分别映射到不同的进程空间中实现进程间通信。当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以需要实现同步与互斥机制。

### 如何进行磁盘调度？
* 先来先服务
* 最短寻道时间优先sstf：会有饥饿现象
* 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。


### wait和waitpid是干嘛的？
```c
pid_t wait(int *status)
```

父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。

参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。

```c
pid_t waitpid(pid_t pid, int *status, int options)
```
作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。

options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。


Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。

系统调用mmap()通过映射一个普通文件实现共享内存。

系统V则是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统shm中的一个文件（这是通过shmid_kernel结构联系起来的）

mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。



因为用来访问内存以得到指令或数据的时间要比执行指令花费的时间长的多，因此，所有的CPU内部都有一些用来保存关键字变量和临时数据的寄存器。

通用寄存器：保存变量和临时结果
程序计数器：程序员可见，保存将要读取的下一条指令的内存地址
堆栈指针：程序员可见。指向内存当中当前栈的顶端。栈当中包含了每个执行过程的栈帧。一个过程的栈帧中包含输入参数、局部变量和没有保存在寄存器中的临时变量。
程序状态字寄存器：包含条件码位、CPU优先级、CPU模式（内核态和用户态）和其他控制位。


计算机是如何启动的？
“在计算机启动时，BIOS开始运行。它首先检查所安装的RAM数量，键盘和其他基本设备是否已安装并正常响应。接着，它开始扫描ISA和PCI总线并找出连在上面的所有设备。其中有些设备是典型的遗留设备（即在即插即用发明之前设计的），并且有固定的中断级别和I/O地址（也许能用在I/O卡上的开关和跳接器设置，但是不能被操作系统修改）。这些设备被记录下来。即插即用设备也被记录下来。如果现有的设备和系统上一次启动时的设备不同，则配置新的设备。

然后，BIOS通过尝试存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚启动之后进入一个BIOS配置程序，对设备清单进行修改。典型地，如果存在软盘，则系统试图从软盘启动。如果失败则试用CD-ROM，看看是否有可启动CD-ROM存在。如果软盘和CD-ROM都没有，系统从硬盘启动。“启动设备上的第一个扇区被读入内存并执行。这个扇面中包含一个对保存在启动扇面末尾的分区表检查的程序，以确定哪个分区是活动的。然后，从该分区读入第二个启动装载模块。来自活动分区的这个装载模块被读入操作系统，并启动之。

然后，操作系统询问BIOS，以获得配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的CD-ROM（由设备供应商提供）。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或GUI。”

#### 每个进程中的内容
地址空间、全局变量、打开文件、子进程、即将发生的定时器、信号与信号处理程序、账户信息

#### 每个线程中的内容
程序计数器、寄存器、堆栈、状态


